#!/bin/bash
#
# git-transform - manages special Git branches for automatic content transformations
#
# HISTORY
#   20140702 first version by JF Gigand <jf@geonef.fr>

# [ "x$NEF_DIR_USR" = x ] && NEF_DIR_USR=/usr
nef_command_name=git-transform
. $(dirname $0)/../share/nef-common/shell-command || exit 2

# . $NEF_DIR_USR/share/nef-common/shell-command


######################################################################
# DEFAULTS AND FUNCTIONS

# Name of our work dir inside GIT's own .git directory
#   will set "git_transform_work_path"
GIT_TRANSFORM_WORK_DIR=$nef_command_name

# Where to look for transform definition files, as a subdirectory
# of the transform branch tree
GIT_TRANSFORM_ENGINE_DIR=$nef_command_name

# Where the GIT bare repository lies from within the container FS
GIT_TRANSFORM_CONTAINER_REPOSITORY=/repository.git

nef_command_usage() {
    cat <<-EOF
	$nef_command_callname - manage data transformations through GIT

	TRANSFORM PLUMBING COMMANDS

	  $nef_command_callname mksync <transform-ref>

	      Create a new sync for the given transform which is a tree-ish reference
	      to a transform engine implementation that provide enough information
	      to be runned as a Docker container.

	      <transform-ref> can be a branch name, a commit ID or any other tree-ish thing


	  $nef_command_callname show-channels [options] <sync-commit-ref> [<channel-name>]

	      <sync-commit-ref> is a sync commit reference of which channels must be listed

	      <channel-name> is the channel name. Valid values would be given by:
	      \$($nef_command_callname show-channels --all --name <sync-commit-ref>)

	      --all     Include the "transform" channel in the channel list
	      --hash    Just print the hash ID
	      --name    Just print the channel name
	      --shell   Print "name=ID" lines that can be eval'ed by a shell


	  $nef_command_callname apply <sync-commit-ref> <channel-name> <commit-ref>

	      Merge the given commit into the sync, interpreted through the given channel.

	      <sync-commit-ref> is a reference to the sync to base the transform application on.

	      <channel-name> is the name of the channel, like "in", "out", "source",
              "build"... or "transform". Use the "transform" channel to update the transform
	      engine (instead of the data).

	      <sync-commit-ref> is a reference to the commit to merge. IT MUST BE SINGLE
	      COMMIT! Branch refs like "master" can be given, but merging multiple commits
	      won't work. For that, use "$nef_command_callname" instead.

	EOF
}

# args: <subdir> <commit-ref>
_nef_tr_git_checkout_work()
{
    _wcpath="$1"
    _commit=$2

    if [ -d "$_wcpath" ]; then
        cd "$_wcpath"
        nef_cmd git fetch --quiet origin
    else
        nef_cmd git clone --quiet --no-checkout --reference  "$nef_git_dir" "$nef_git_dir" "$_wcpath" \
            || nef_fatal "git clone failed, try --debug-verbose"
        cd "$_wcpath"
    fi

    nef_cmd git reset --quiet --hard $_commit || nef_fatal "git reset failed, try --debug-verbose"
    # nef_cmd git checkout $_commit || nef_fatal "git reset failed, try --debug"
}

# args: <transform-tree-ish> <command> [args] ...
nef_tr_run_transform_command()
{
    local _transform_commit=$1; shift
    local _command=$1; shift
    local _last_transform_dir=last-transform
    local _wcpath="${git_transform_work_path}/${_last_transform_dir}"

    _nef_tr_git_checkout_work "$_wcpath" $_transform_commit
    cd $_wcpath || nef_fatal "could not chdir to $_wcpath"
    nef_log -v "Updated $_wcpath"

    if [ "x$_command" != x_shell ]; then
        [ -f $GIT_TRANSFORM_ENGINE_DIR/$_command ] \
            || nef_fatal "$GIT_TRANSFORM_ENGINE_DIR/$_command does not exist in transform tree"
    fi

    local _engine_path=$GIT_TRANSFORM_ENGINE_DIR/engine
    local _engine=$(cat $_engine_path) || nef_fatal "missing file '${_engine_path}'"

    nef_log --debug "engine spec = $_engine"
    type=$(echo $_engine | cut -d: -f1)
    [ "x$type" = xdocker ] || nef_fatal "$_enginepath: only the 'docker:' type is supported ('$type')"
    dockertype=$(echo $_engine | cut -d: -f2)
    dockername=$(echo $_engine | cut -d: -f3)

    GIT_TRANSFORM_CONTAINER_CHANNEL_TRANSFORM=$_transform_commit
    GIT_TRANSFORM_CONTAINER_GIT_AUTHOR_NAME=$(git config user.name)
    GIT_TRANSFORM_CONTAINER_GIT_AUTHOR_EMAIL=$(git config user.email)
    GIT_TRANSFORM_CONTAINER_LOG=$GIT_TRANSFORM_CONTAINER_REPOSITORY/${GIT_TRANSFORM_WORK_DIR}/${_last_transform_dir}/log

    rm -f log
    touch log

    docker_v_opts="-v $nef_git_dir:$GIT_TRANSFORM_CONTAINER_REPOSITORY"
    docker_env_opts=
    for var in $(compgen -v | grep ^GIT_TRANSFORM_CONTAINER_ ); do
        nef_log --debug "Exporting: $var=${!var}"
        docker_env_opts="$docker_env_opts -e $var=${!var}"
    done

    _full_command_path="${GIT_TRANSFORM_CONTAINER_REPOSITORY}/${GIT_TRANSFORM_WORK_DIR}/${_last_transform_dir}/${GIT_TRANSFORM_ENGINE_DIR}/${_command}"
    [ "$_command" = _shell ] && _full_command_path=/bin/bash

    case "$dockertype" in
        image)
            nef_log -v "Running Docker image '${dockername}' for command '${_command}'"
            nef_cmd --debug-name DOCKER sudo \
                docker.io run -t -i --rm=true $_docker_opts $docker_v_opts $docker_env_opts $dockername \
                $_full_command_path \
                "$@"
            cat log | nef_log_pipe --verbose "TRANSFORM:"
            ;;
        container)
            nef_fatal "docker type 'container' not implemented yet"
            ;;
        *)
            nef_fatal "$_engine_path: invalid docker type '$dockertype' (must be 'image' or 'container')"
            ;;
    esac

}

_to_git_tree()
{
    git cat-file -e "$1" || nef_fatal "'$1' is not a tree-ish object"
    git rev-parse "$1" || nef_fatal "'$1' could not be resolved to a commit"
}
nef_tr_command_shell() {
    [ "x$1" = x ] && nef_fatal_usage "missing arg: <transform-commit>"
    _transform_commit="$1"; shift

    nef_tr_run_transform_command $(_to_git_tree "$_transform_commit") _shell "$@"
}

nef_tr_command_mksync() {
    [ "x$1" = x ] && nef_fatal_usage "missing arg: <transform-commit>"
    _transform_commit="$1"; shift

    nef_tr_run_transform_command $(_to_git_tree "$_transform_commit") mksync "$@"
}

nef_tr_command_show_channels() {
    nef_tr_run_transform_command show-channels "$@"
}

nef_tr_command_apply() {
    nef_tr_run_transform_command apply "$@"
}

nef_command_merge_env

######################################################################
# COMMAND LINE & RUN

nef_command_init_options
nef_tr_command_argv=()

while [ "$1" != "" ]; do

    case "$1" in
        -v | --verbose) nef_opt_show_verbose=yes; shift ;;
        -vv | --debug-verbose) nef_opt_show_verbose=yes; nef_opt_show_debug=yes; shift ;;
        -h | --help) nef_show_usage; exit 0 ;;
        -*) nef_fatal_usage "bad option: $1" ;;
        *) nef_tr_command_argv=(${nef_tr_command_argv[@]} "$1"); shift ;;
    esac

done

[ "x${nef_tr_command_argv[0]}" = "x" ] && nef_fatal_usage "missing command"

# Load $nef_git_dir as absolute path
_nef_git_dir=$(git rev-parse --git-dir) || nef_fatal "not in a git repository"
cd $_nef_git_dir
nef_git_dir=$PWD
unset _nef_git_dir
cd - >/dev/null

# Repository-specific variables
git_transform_work_path="${nef_git_dir}/${GIT_TRANSFORM_WORK_DIR}"


# Run command
nef_tr_command_function_name="nef_tr_command_${nef_tr_command_argv[0]}"
unset nef_tr_command_argv[0]
$nef_tr_command_function_name "${nef_tr_command_argv[@]}" \
    || nef_fatal "command ${nef_tr_command_argv[0]} returned status $?"
nef_log -v "Command returned successfully."
